Python Object
===============
对象机制
---------
1. python中对象机制的核心只有两点，p18

2. 如何理解这个python的“对象核心机制”？

- 在python中，所有的东西都是对象，而所有的对象都拥有一些相同的内容，p19 图1-1，而这些内容都定义在一个宏之中，p17
- python创建了任何类型的对象后，在其内部，只会用PyOjbect \*来指向，就是\*ob_type实现了Python这种对象的多态,p25

3. 当我们谈论python对象时，要关注两个struct及各自存储的内容（为什么会有如此分离的设计？）

- 对象本身，保存在“对象类型”的定义中，例如PyIntObject定义了整数对象
- 对象元信息，保存在对象对应的“类型对象”中，包括的元信息有p31

其实，无论在“交互模式”还是在“.py模式”使用python时，我们无时不刻不是在访问对象及其元信息：

.. code-block:: python
	:linenos:

	#访问的是静态的整数对象的定义PyIntObject中的属性ob_ival
	>>>a = 1
	#访问的是元信息，即“类型对象”中的属性int_doc
	>>>print(a.__doc__)

4. python中，所有的对象都存活在“系统堆”上

类型对象
---------
- 每个类型对象其实就是一个PyTypeObject实例
- 类型对象就是面向对象理论中“类”这个概念的实现

.. _obj-behavior:

对象的行为
^^^^^^^^^^^
什么叫“对象的行为”？5+6，a['key'], b[0], print(10),等等

为什么数值型、序列型和关联型对象有如此不同的行为？由类型对象中三个函数指针所指向的“函数族”的实现情况决定p23

python允许数值型对象拥有关联型对象的行为吗？允许的，从客户端代码的表现形式就是p23 图1-4；从底层实现来看，p24第一段

对象的行为属于对象的“元信息”，由对应的类型对象来定义

类型对象的初始化
^^^^^^^^^^^^^^^^^
为什么python中的“内建类型对象”都是被静态初始化的？意味着它们不在内存的堆栈区，而是在全局区（静态区）p16，所以，类型对象永远不会被析构p27

对象分类
---------
p28 图1-7，书中根据什么把python对象分为这5类（类型对象），是对象行为吗？

对象的静态实现
---------------
+--------------+------------+--+
| 静态对象定义 | 类型对象   |  |
+--------------+------------+--+
| PyIntObject  | PyInt_Type |  |
+--------------+------------+--+
|              |            |  |
+--------------+------------+--+

1. 为什么像js， python这样的语言，把一切都当成对象呢？连类型都是“类型对象” p15

对象的运行时
------------
当谈论对象运行时，可以从两个维度来看：

1. 运行时，对象及其类型之间的关系，p25 图1-6
2. 对象生命周期各个阶段在内存中的形态及组织形式

对象和类型之间的关系
^^^^^^^^^^^^^^^^^^^^
运行时整数对象及其类型之间的关系，p25 图1-6

对象池
^^^^^^^^
1. 为什么几乎所有的内建对象，都有自己特有的“对象池机制”？

- 缓解因采用“引用计数机制”，“系统堆”会面临着对象访问瓶颈——当引用计数减为0时，频繁申请、释放内存空间会使python的执行效率大打折扣，p17 ob_refcnt, p43 惊天隐秘
- 对象并非独立对象，而是通过一定结构连接在一起的庞大的对象系统

INT对象（定长对象）运行时
-------------------------
运行时整数对象及其类型之间的关系
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
p25 图1-6

INT对象池
^^^^^^^^^^^^^^^^^^^^^
- int对象池的基础结构是PyIntBlock，这个基础结构的构建代码（p36-37,2.2.3）和内存布局（p39图2-4）
- 以上述基础结构为基础，创建对象池的代码见p38代码清单2-3, 链表图示p40图2-6
- 在同一个对象池中存在两个单向链表，block_list指向的"block chain"，free_list指向的"空闲PyIntObject对象"链表
- “空闲空间单向列表”的形成见p38函数fill_free_list(), 在整个链接过程中，使用了PyObject中的ob_type指针作为连接指针
- 如果对象池中存在空闲空间，那么新创建的int对象肯定使用的是free_list指向的那个，这个被使用的空闲空间的ob_type指针转而指向PyInt_Type，以表明这是一个int对象

小整数和大整数
^^^^^^^^^^^^^^^
+---------------------------------------------+---------------------------------------------+
|                    小整数                   |                    大整数                   |
+---------------------------------------------+---------------------------------------------+
| 存储于int block chain中                     | 同左                                        |
+---------------------------------------------+---------------------------------------------+
| [-5, 257]                                   | 其他                                        |
+---------------------------------------------+---------------------------------------------+
| 在程序初始化时就创建好了                    | 只在需要时才创建                            |
+---------------------------------------------+---------------------------------------------+
| 内存中只会存在唯一值的小整数对象，p46图2-13 | ob_ival相同的大整数对象使用一次就创建一次， |
|                                             | 存于不同的地址，见p45图2-11                 |
+---------------------------------------------+---------------------------------------------+
| 永远不会被释放，因为p43                     | ob_refcnt==0就释放                          |
+---------------------------------------------+---------------------------------------------+

变长对象
---------
变长对象的实现机制
^^^^^^^^^^^^^^^^^^
p48，主要由两个部分来实现：

1. 指针，指向变长对象所维护的实际内容的一段内存
2. ob_size, 这段内存的实际长度（字节）