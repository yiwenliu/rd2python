Python Object
===============
对象机制
---------
1. python中对象机制的核心只有两点，p18

2. 如何理解这个python的“对象核心机制”？

- 在python中，所有的东西都是对象，而所有的对象都拥有一些相同的内容，p19 图1-1，而这些内容都定义在一个宏之中，p17
- python创建了任何类型的对象后，在其内部，只会用PyOjbect \*来指向，就是\*ob_type实现了Python这种对象的多态,p25

3. 当我们谈论python对象时，要关注两个struct及各自存储的内容（为什么会有如此分离的设计？）

- 对象本身，保存在“对象类型”的定义中，例如PyIntObject定义了整数对象
- 对象元信息，保存在对象对应的“类型对象”中，包括的元信息有p31

其实，无论在“交互模式”还是在“.py模式”使用python时，我们无时不刻不是在访问对象及其元信息：

.. code-block:: python
	:linenos:

	#访问的是静态的整数对象的定义PyIntObject中的属性ob_ival
	>>>a = 1
	#访问的是元信息，即“类型对象”中的属性int_doc
	>>>print(a.__doc__)

4. python中，所有的对象都存活在“系统堆”上

类型对象
---------
- 每个类型对象其实就是一个PyTypeObject实例
- 类型对象就是面向对象理论中“类”这个概念的实现

.. _obj-behavior:

对象的行为
^^^^^^^^^^^
什么叫“对象的行为”？5+6，a['key'], b[0], print(10),等等

为什么数值型、序列型和关联型对象有如此不同的行为？由类型对象中三个函数指针所指向的“函数族”的实现情况决定p23

python允许数值型对象拥有关联型对象的行为吗？允许的，从客户端代码的表现形式就是p23 图1-4；从底层实现来看，p24第一段

对象的行为属于对象的“元信息”，由对应的类型对象来定义

类型对象的初始化
^^^^^^^^^^^^^^^^^
为什么python中的“内建类型对象”都是被静态初始化的？意味着它们不在内存的堆栈区，而是在全局区（静态区）p16，所以，类型对象永远不会被析构p27

对象分类
---------
p28 图1-7，书中根据什么把python对象分为这5类（类型对象），是对象行为吗？

对象的静态实现
---------------
+--------------+------------+--+
| 静态对象定义 | 类型对象   |  |
+--------------+------------+--+
| PyIntObject  | PyInt_Type |  |
+--------------+------------+--+
|              |            |  |
+--------------+------------+--+

1. 为什么像js， python这样的语言，把一切都当成对象呢？连类型都是“类型对象” p15

对象的运行时
------------
当谈论对象运行时，可以从两个维度来看：

1. 运行时，对象及其类型之间的关系，p25 图1-6
2. 对象生命周期（尤其是创建和销毁）各个阶段，在内存中的形态及组织形式

对象和类型之间的关系
^^^^^^^^^^^^^^^^^^^^
运行时整数对象及其类型之间的关系，p25 图1-6

对象池
^^^^^^^^
1. 为什么几乎所有的内建对象，都有自己特有的“对象池机制”？

- 缓解因采用“引用计数机制”，“系统堆”会面临着对象访问瓶颈——当引用计数减为0时，频繁申请、释放内存空间会使python的执行效率大打折扣，p17 ob_refcnt, p43 惊天隐秘
- 对象并非独立对象，而是通过一定结构连接在一起的庞大的对象系统

2. 从两个方面来考虑对象池：

1）新建对象的内存空间从哪里来

2）销毁对象时，空间去哪里

INT对象（定长对象）运行时
-------------------------
运行时整数对象及其类型之间的关系
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
p25 图1-6

INT对象池
^^^^^^^^^^^^^^^^^^^^^
整体内存布局
++++++++++++++++++++
把两幅图结合起来，就是INT对象池的整体内存布局

1. p40 图2-6
2. p43 图2-9

全局指针
+++++++++
int对象池由三个全局指针来维护,small_ints(p36), block_list和free_list（p37），注意这三个指针的数据类型。


PyIntBlock
+++++++++++++
int对象池的基础结构是PyIntBlock，这个基础结构的构建代码（p36-37,2.2.3）和内存布局（p39图2-4）

在同一个对象池中存在两个单向链表，block_list指向的"block chain"，free_list指向的"空闲PyIntObject对象"链表

基于PyIntBlock，可以回答如下的问题:

- 是否每新建一个int对象，都要在堆中申请一次size(PyIntObject)空间？不是。当free_list=NULL时，表示对象池中无剩余空间，一次性申请size(PyIntBlock)的空间，创建对象池的代码见p38代码清单2-3

- 内存中int对象是否是离散存在的？不是。每个int对象都存在于“PyIntBlock链表”的某个PyIntBlock中。

- 新建的int对象如何利用free_list指向的“空闲内存块单向链表”？如果对象池中存在空闲空间，那么新创建的int对象肯定使用的是free_list指向的那个，这个被使用的空闲空间的ob_type指针转而指向PyInt_Type，以表明这是一个int对象

- 引用为0的int对象的空间是否被释放？不会释放。从两个方面来考虑这个问题：1）本来申请空间时就不是以size(PyIntObject)为单位申请的；2）这种对象会被对象池回收，即重新链入由free_list指向的“空闲内存块单向链表”中，可以参见p41 int_dealloc()实现，以及p41-42对这个函数的解释。

- “空闲空间单向列表”是如何形成的？分为两个阶段，1)初始化，见p38-2.2.4.2-函数fill_free_list()；2）当某个int对象的引用计数为0时，见p41 int_dealloc()实现，以及p41-42对这个函数的解释。在整个链接过程中，使用了PyObject中的ob_type指针作为连接指针

小整数和大整数
^^^^^^^^^^^^^^^
+---------------------------------------------+---------------------------------------------+
|                    小整数                   |                    大整数                   |
+---------------------------------------------+---------------------------------------------+
| 存储于int block chain中                     | 同左                                        |
+---------------------------------------------+---------------------------------------------+
| [-5, 257]                                   | 其他                                        |
+---------------------------------------------+---------------------------------------------+
| 在程序初始化时就创建好了                    | 只在需要时才创建                            |
+---------------------------------------------+---------------------------------------------+
| 内存中只会存在唯一值的小整数对象，p46图2-13 | ob_ival相同的大整数对象使用一次就创建一次， |
|                                             | 存于不同的地址，见p45图2-11                 |
+---------------------------------------------+---------------------------------------------+
| 永远不会被释放，因为p43                     | ob_refcnt==0就释放                          |
+---------------------------------------------+---------------------------------------------+

变长对象
---------
变长对象的实现机制
^^^^^^^^^^^^^^^^^^
因为对于变长对象而言，对象维护的数据的长度在对象定义时时不知道的。所以，p48，其机制主要由三个不同部分来共同实现：

1. 指针，指向变长对象所维护的实际内容的一段内存。在某个具体的“变长对象”中定义，例如，p48,PyStringObject

2. ob_size, 这段内存的实际长度（字节）。在PyVarObject中定义

3. tp_itemsize,由变长对象保存的元素的单位长度。在类型对象中定义，例如，PyString_Type中tp_itemsize=sizeof(char),p49

String对象
------------
PyStringObject定义
^^^^^^^^^^^^^^^^^^^
PyStringObject的定义p48，有两个重要的成员：

- ob_shash
- ob_sstate

其对应的类型对象的定义PyString_Type,p49

全局指针和内存池
^^^^^^^^^^^^^^^^^^
string对象在运行时有两个全局指针作为内存池在起作用:

1. interned, p54
2. characters, p56

内存布局
^^^^^^^^^
一个string对象是如何创建出来的？PyString_FromString()，这个函数书中分了两个部分来讲，1)  p49-代码清单3-1, 2)  p52。

- 内存中string header和payload是不连续的空间吗？非也，p51图3-1，由图可得，对象header和对象payload是连续的内存空间。
- 是否每新建一个string对象就申请一次内存空间呢？只要payload的size>1就会申请内存，而无论这个string对象是否在对象池中，p55。然后再进行检查，如果interned dict中存在维护着相同原生字符串的PyStringObject对象，就会释放新申请的堆空间，让对象变量转而指向已经存在于dict中的PyStringObject对象。
- 所有的string对象是松散的存在于内存中吗？非也，python提供一个interned指向的dict，作为部分PyStringObject对象的内存池，称为“intern机制”。
- 这个interned dict是怎么缓存PyStringObject对象的呢，是放在dict的value中吗？非也，dict的key和value都是PyStringObject对象的指针，p54图3-2。
- 哪些string对象可以进入这个dict呢？从p52中创建string对象的后半部分代码可得，只有长度较短的（长度为0或者1）string才能进入和dict缓存。
- 对一个string对象的intern操作包括哪些动作？p53，代码清单3-2
- 一个string对象的引用为0后，会销毁其占用的内存空间吗？会的。无论它是否加入了interned dict中。

List对象
---------
PyListObject定义
^^^^^^^^^^^^^^^^^^^^
PyListObject是一个变长、可变对象，这两个特征都要靠定义中的成员属性来体现，p63-64

可变对象的实现机制
+++++++++++++++++++++++++++
ob_item, allocated&ob_size，这三个成员属性相互协作，实现了list对象的可变以及变长的特性。

allocated和ob_size的值有一些微妙的关系，详细讲解见p64-4.1。

在list的生命周期（对象的创建、对list元素进行插值和删除、list对象的销毁）中，这两个属性（allocated和ob_size）的取值有一些相应的联系，可见p75 4.4前半部分的例子。

创建对象
^^^^^^^^^
创建对象的代码见p64 代码清单4-1，创建完成后的内存布局见p67 图4-1

1. 创建一个list对象包括创建list所维护的元素吗？

非也。创建一个list对象包括了两个部分，且其中，元素指针列表都为NULL

2. list维护的“元素指针列表”和“PyListObject对象本身”是连续的内存空间吗？

非也。从p67 图4-1看的一清二楚。如此设计，也是为了实现list的可变对象属性。

3. list_a = [1,2,'pyhton']的实现过程。

应该是经历了两个阶段，1）新建list_a对象(size=4)，2)对list_a进行四次“设置元素”的操作。

4. 创建list对象时所使用的内存空间来自于对象缓冲池吗？

非也且不全是。首先，从1）list对象内存池的定义p66，以及2）list对象的销毁操作（p74）来看，PyListObject对象缓冲池只是一个“指针数组”而已，先有list对象销毁，才会把其中PyListObject对象本身那一个部分存入缓冲池，也就是说，没有list对象销毁，缓冲池中无内存空间可用；其次，即使从对象缓冲池中获取内存，也只有“PyListObject对象本身”这一部分，而“元素指针列表”部分，还是要重新申请。

对象的销毁和缓冲池
^^^^^^^^^^^^^^^^^^
1. list对象内存池的定义p66

其实，就是一个指针数组

2. list对象的销毁操作（p74）

3. 销毁list对象的过程以及哪些内存空间可以进入缓冲池？

销毁list可以分为三步：

1） 销毁list维护的元素，各类型的元素有自己的内存回收方法；

2） 销毁list中ob_item指向的“元素指针数组”所占用的内存空间；

3） PyListObject对象本身占用的内存空间归入缓冲池。

4. 缓冲池在程序初始化时就申请了内存空间了吗？

非也。list对象的缓冲池本质上就是一个指针数组，在初始化时只是申请了数组相应的全局变量空间。而真正的PyListObject对象空间却是来自于回收的要销毁的list对象的部分内存空间。

insert, append
^^^^^^^^^^^^^^^^
1. insert和append操作必然会导致ob_item指向的内存发生变化吗？

不会。是否需要增加ob_item指向的指针数组所占用的空间进行，需要看p69 list_resize()解释。

2. 如果需要增加内存空间，是否和insert/append的元素个数相同呢？

非也。从p69 list_resize()可见，ob_item指向的指针数组所增加的内存空间会大于实际insert/append的元素个数。

delete
^^^^^^^
1. delete元素后，会减少ob_item指向的指针数组所占用的空间？

不一定，需要看p69 list_resize()解释。
